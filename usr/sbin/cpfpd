#!/usr/bin/python

## Copyright (C) Amnesia <amnesia at boum dot org>
## Copyright (C) 2014 troubadour <trobador@riseup.net>
## Copyright (C) 2014 Patrick Schleizer <adrelanos@riseup.net>
## See the file COPYING for copying conditions.

# This filter proxy should allow Torbutton to request a
# new Tor circuit, without exposing dangerous control requests
# like "GETINFO address" to applications running as a local user.

# If something goes wrong, an error code is returned, and
# Torbutton will display a warning dialog that New Identity failed.

# issues:
# - Should the first message not be 'authenticate', then Tor already closes the
#   connection and subsequent messages are ignored. No real world application
#   known to have issues with that.
# - Should Tor unexpectedly close the connection, then the client connection is
#   not closed.
# - Tor authentication reply is not checked for success.
# - Many exception handling TODOs. However it keeps the code shorter and these
#   exceptions that can happen in corner cases would not prevent new client
#   connections from being successful.

# test cases:
# - Tor Browser newnym
# - tor-arm (with filtering disabled)
# - python-stem based applications
# - onionshare

import daemon
from daemon import runner
import gevent
import socket
from gevent.server import StreamServer
import binascii
import os
import glob
import logging
import signal
import sys
import asyncore
import select
import time

class Configuration:
    def read(self):
        # Read and override configuration from files
        if os.path.exists('/etc/cpfpy.d'):
            files = sorted(glob.glob('/etc/cpfpy.d/*.conf'))

            if files:
                conf_found = False
                RequestList = ''
                for conf in files:
                    if not conf.endswith('~') and conf.count('.dpkg-') == 0:
                        conf_found = True
                        with open(conf) as c:
                            for line in c:
                                if '=' in line:
                                    k, value = line.split('=')

                                    if k == 'CONTROL_PORT_FILTER_DISABLE_FILTERING':
                                        self.DISABLE_FILTERING = value.strip() == 'true'

                                    if k == 'CONTROL_PORT_FILTER_LIMIT_STRING_LENGTH':
                                        self.LIMIT_STRING_LENGTH = int(value.strip())

                                    if k == 'CONTROL_PORT_FILTER_ALLOW_WILDCARDS':
                                        self.ALLOW_WILDCARDS = value.strip() == 'true'

                                    if k ==  'CONTROL_PORT_FILTER_LIMIT_GETINFO_NET_LISTENERS_SOCKS':
                                        self.LIMIT_GETINFO_NET_LISTENERS_SOCKS = value.strip() == 'true'

                                    if k == 'CONTROL_PORT_FILTER_WHITELIST':
                                        # concatenate values from files, add a comma
                                        RequestList = RequestList + value.strip() + ','

                                    if k == 'CONTROL_PORT_FILTER_PORT':
                                        self.PORT = int(value.strip())

                                    if k == 'CONTROL_PORT_FILTER_IP':
                                        self.IP = str(value.strip())

                                    if k == 'CONTROL_PORT_SOCKET':
                                        self.SOCKET = str(value.strip())

                                    if k == 'CONTROL_PORT_AUTH_COOKIE':
                                        self.AUTH_COOKIE = str(value.strip())

                                    if k == 'CONTROL_PORT_FILTER_CONCURRENT_CONNECTIONS_LIMIT':
                                        self.CONTROL_PORT_FILTER_CONCURRENT_CONNECTIONS_LIMIT = int(value.strip())

                if not conf_found:
                    self.set_default()
                    return ('No valid file found in user configuration folder "/etc/cpfpy.d".'\
                            ' Running with default configuration.')

                # Disable limit.
                if self.LIMIT_STRING_LENGTH == -1:
                    # "sock.recv()" requires an argument. 64 KB, arbitrary.
                    self.LIMIT_STRING_LENGTH = 65536

                self.WHITELIST = RequestList.split(',')
                # Remove last element (comma)
                self.WHITELIST.pop()
                # Remove duplicates
                self.WHITELIST = list(set(self.WHITELIST))

            else:
                self.set_default()
                return('No file found in user configuration folder "/etc/cpfpy.d".'\
                        ' Running with default configuration.')

        else:
            self.set_default()
            return('User configuration folder "/etc/cpfpy.d" does not exist.'\
                    ' Running with default configuration.')

    def set_default(self):
        # Default control port filer configuration
        self.IP = '10.152.152.10'
        self.PORT = 9052
        self.SOCKET = '/var/run/tor/control'
        self.AUTH_COOKIE = '/var/run/tor/control.authcookie'
        self.DISABLE_FILTERING = False
        self.LIMIT_STRING_LENGTH = 16384
        self.LIMIT_GETINFO_NET_LISTENERS_SOCKS = True
        self.WHITELIST = ['signal newnym', 'getinfo net/listeners/socks',
                    'getinfo status/circuit-established', 'quit']
        self.CONTROL_PORT_FILTER_CONCURRENT_CONNECTIONS_LIMIT = 5
        self.ALLOW_WILDCARDS = False


class UnexpectedAnswer(Exception):
    def __init__(self, msg):
        self.msg = msg

    def __str__(self):
        return "[UnexpectedAnswer] " + self.msg


class DoRequestReal(asyncore.dispatcher):
    def __init__(self, client_socket):
        self.configuration = Configuration()
        self.configuration.read()

        self.to_send = ""
        self.client_socket = client_socket
        self.received_data = []
        self.chunk_size = self.configuration.LIMIT_STRING_LENGTH

        asyncore.dispatcher.__init__(self)

        # Connect to the real control port
        self.create_socket(socket.AF_UNIX, socket.SOCK_STREAM)
        self.connect(self.configuration.SOCKET)

        return

    def say(self, request):
        self.to_send = request + "\r\n"
        self.handle_write()

    def handle_connect(self):
        logger.debug('handle_connect() done')

    def handle_close(self):
        logger.debug('handle_close() start')
        self.close()
        received_message = ''.join(self.received_data)
        ## Prevent extraneous new lines in logs.
        output_message = received_message.strip()
        logger.debug('handle_close(): answer by Tor: %s', output_message)
        logger.debug('handle_close(): Closing connection. self.client_socket.close()')
        ## TODO: exception handling
        self.client_socket.close()
        logger.debug('handle_close(): Closed connection on sock. self.client_socket: %s', self.client_socket)
        return

    def readable(self):
        #logger.debug('readable() -> True')
        return True

    def writable(self):
        if self.to_send == "":
           #logger.debug('writable empty: %s', self.to_send)
           return False
        else:
           #logger.debug('writable non-empty: %s', self.to_send)
           return True

    def handle_write(self):
        #logger.debug('handle_write start')
        sent = self.send(self.to_send[:self.chunk_size])
        #logger.debug('handle_write() -> (%d) "%s"', sent, self.to_send[:sent])
        self.to_send = self.to_send[sent:]
        #logger.debug('handle_write done')

    def handle_read(self):
        data = self.recv(self.chunk_size)
        data_stripped = data.strip()
        logger.debug('handle_read(): answer by Tor: %s', (data_stripped))

        ## TODO: exception handling
        self.client_socket.send(data)

        self.received_data.append(data)

    def handle_error(self):
        t, v, tb = sys.exc_info()
        if t == socket.error:
            logger.error('ERROR: %s' % (t))


class ControlPortFilter(asyncore.dispatcher):
    def __init__(self, sock, configuration):
        asyncore.dispatcher.__init__(self, sock=sock)

        self.configuration = configuration
        self.tor_connection = DoRequestReal(self)
        self.request_buffer = ''

    def request_contains_wildcard(self, request):
        for item in self.configuration.WHITELIST:
            if '*' in item:
                item = item[:len(item)-2]
                if item in request:
                    return True
        return False

    def handle_read(self):
        logger.debug('stream_server_handler: Getting command on sock: %s'
                     % (self))

        client_line = self.recv(self.configuration.LIMIT_STRING_LENGTH)
        if not client_line:
            ## Client probably disconnected.
            need_request = False
            do_break = True
            ## TODO
            request = "quit"
        else:
            self.request_buffer += client_line
            if '\r\n' not in self.request_buffer:
                # wait for more
                return
            request_end = self.request_buffer.find('\r\n')
            # Strip escaped chars and white spaces.
            # Convert to lowercase.
            request = self.request_buffer[:request_end].lower().strip()
            self.request_buffer = self.request_buffer[request_end + 2:]

        logger.info('stream_server_handler: request: %s' % (request))
        request_startswith = request.split(' ', 1)[0]

        # Don't check authentication, since only
        # safe requests are allowed
        if request_startswith == "authenticate":
            try:
                authentication_cookie_file_socket = open(self.configuration.AUTH_COOKIE, "rb")
                rawcookie = authentication_cookie_file_socket.read(32)
                authentication_cookie_file_socket.close()
                hexcookie = binascii.hexlify(rawcookie)
                request = "AUTHENTICATE " + hexcookie
                logger.debug('stream_server_handler: request transformed to: %s' % (request))
                need_request = True
                do_break = False
            except:
                logger.error("stream_server_handler: Authentication request message generation failed. Hopefully below this line is a better error message.")
                exception_msg = str(sys.exc_info()[0])
                logger.error(exception_msg)
                need_request = False
                do_break = True
                answer_faked = "515 Authentication failed: control-port-filter-python stream_server_handler authentication message generation failed. exception_msg: " + exception_msg

        elif request_startswith == "authchallenge":
            need_request = False
            do_break = False
            answer_faked = "250 AUTHCHALLENGE SERVERHASH=D3A6FF5943582E95E3B8C5449AF30EC6A11BBB1513DE0ED9ED50AC6075046F48 SERVERNONCE45CBD16FCF5D9A529F0B3BF0F04E677609CDADA11E0"

        elif request_startswith == "quit":
            need_request = True
            do_break = True

        elif (request == 'getinfo net/listeners/socks' and self.configuration.LIMIT_GETINFO_NET_LISTENERS_SOCKS):
            need_request = False
            do_break = False
            answer_faked = '250-net/listeners/socks="127.0.0.1:9150"'

        elif (self.configuration.ALLOW_WILDCARDS and self.request_contains_wildcard(request)):
            need_request = True
            do_break = False

        elif self.configuration.DISABLE_FILTERING:
            need_request = True
            do_break = False

        elif request in self.configuration.WHITELIST:
            need_request = True
            do_break = False

        else:
            # Everything else we ignore/block
            need_request = False
            do_break = False
            answer_faked = "510 Request filtered"

        if need_request == True:
            self.tor_connection.say(request)
            if request_startswith == "quit":
                ## Give it half a second to catch Tor's answer before
                ## actually closing the client socket later.
                asyncore.loop(timeout=0.1, count=5)

        else:
            answer_faked = answer_faked + "\r\n"
            answer_faked_strip = answer_faked.strip()
            logger.info('stream_server_handler: answer_faked by cpfpy: "%s"' % (answer_faked_strip))
            ## TODO: exception handling
            self.send(answer_faked)

        if do_break == True:
            logger.debug('stream_server_handler: Closing connection on '
                         'sock: %s' % (self))
            ## TODO: exception handling
            self.close()

    def handle_close(self):
        logger.debug('stream_server_handler: End of connection on sock: %s' %
                     (self))
        self.tor_connection.close()

class ControlPortFilterServer(asyncore.dispatcher):
    def __init__(self):
        asyncore.dispatcher.__init__(self)

        self.stdin_path = '/dev/null'
        self.stdout_path = '/dev/null'
        self.stderr_path = '/dev/null'
        self.pidfile_path =  '/var/run/control-port-filter-python/pid'
        self.pidfile_timeout = 5

        self.connections = []


    def handle_accept(self):
        conn, addr = self.accept()
        self.connections.append(
            ControlPortFilter(conn, configuration=self.configuration))

    def run(self):
        self.configuration = Configuration()
        maybe_warning_message = self.configuration.read()
        if maybe_warning_message is not None:
            logger.warning(maybe_warning_message)

        # Catch server exceptions.
        try:
            logger.debug("Trying to start Tor control port filter on    IP %s port %s"
                        % (self.configuration.IP, self.configuration.PORT))
            # Accept concurrent connections.
            self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
            self.bind((self.configuration.IP, self.configuration.PORT))
            # it isn't exactly connection limit - it a queue depth for
            # connections waiting to be handled
            self.listen(self.configuration.CONTROL_PORT_FILTER_CONCURRENT_CONNECTIONS_LIMIT)

            logger.debug("Tor control port filter started, listening on IP %s port %s"
                        % (self.configuration.IP, self.configuration.PORT))
        except IOError as e:
            logger.critical('Server error %s' % (e))
            logger.critical('Exiting.')
            sys.exit(1)

        asyncore.loop()

if __name__ == "__main__":
    mypid = os.getpid()
    log_prefix = "CPFP " + str(mypid) + " log"
    logger = logging.getLogger(log_prefix)
    logger.setLevel(logging.DEBUG)
    formatter = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")
    handler = logging.FileHandler('/var/log/control-port-filter-python.log')
    handler.setFormatter(formatter)
    logger.addHandler(handler)

    # Create daemon.
    cpfp = ControlPortFilterServer()

    print "start"
    print mypid

    ## For debugging, comment out daemon_runner and use this.
    cpfp.run()

    #daemon_runner = runner.DaemonRunner(cpfp)

    # The daemon closes all the file handles by default.
    # Preserve the logger.
    #daemon_runner.daemon_context.files_preserve=[handler.stream]

    # Start the daemon
    #daemon_runner.parse_args()
    #daemon_runner.do_action()
