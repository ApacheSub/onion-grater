#!/usr/bin/python

## Copyright (C) Amnesia <amnesia at boum dot org>
## Copyright (C) 2014 troubadour <trobador@riseup.net>
## Copyright (C) 2014 Patrick Schleizer <adrelanos@riseup.net>
## See the file COPYING for copying conditions.

# This filter proxy should allow Torbutton to request a
# new Tor circuit, without exposing dangerous control requests
# like "GETINFO address" to applications running as a local user.

# If something goes wrong, an error code is returned, and
# Torbutton will display a warning dialog that New Identity failed.

# issues:
# - Many exception handling TODOs. However it keeps the code shorter and these
#   exceptions that can happen in corner cases would not prevent new client
#   connections from being successful.

# test cases:
# - Tor Browser newnym
# - tor-arm (with filtering disabled)
# - python-stem based applications
# - onionshare

import socket
import binascii
import os
import glob
import logging
import signal
import sys
import asyncore
import commands,re,socket

class Configuration:
    def set_default(self):
        # Default control port filer configuration
        self.IP = '10.152.152.10'
        self.PORT = 9052
        self.SOCKET = '/var/run/tor/control'
        self.AUTH_COOKIE = '/var/run/tor/control.authcookie'
        self.DISABLE_FILTERING = False
        self.LIMIT_STRING_LENGTH = 16384
        self.LIMIT_GETINFO_NET_LISTENERS_SOCKS = True
        self.WHITELIST = ['signal newnym', 'getinfo net/listeners/socks',
                    'getinfo status/circuit-established', 'quit']
        self.CONTROL_PORT_FILTER_CONCURRENT_CONNECTIONS_LIMIT = 5
        self.ALLOW_WILDCARDS = False
        self.ADD_ONION_INJECT_IP = True
        self.ONION_REJECT_OWN_IPS = True

    def read(self):
        self.set_default()

        # Read and override configuration from files
        if not os.path.exists('/etc/cpfpy.d'):
            return ('Configuration folder "/etc/cpfpy.d" does not exist.'\
                    ' Running with default configuration.')

        files = sorted(glob.glob('/etc/cpfpy.d/*.conf'))

        if not files:
            return ('No files in configuration folder "/etc/cpfpy.d".'\
                    ' Running with default configuration.')

        conf_found = False
        RequestList = ''
        for conf in files:
            if conf.endswith('.conf'):
                conf_found = True
                with open(conf) as c:
                    for line in c:
                        if '=' in line:
                            k, value = line.split('=')

                            if k == 'CONTROL_PORT_FILTER_DISABLE_FILTERING':
                                self.DISABLE_FILTERING = value.strip() == 'true'

                            if k == 'CONTROL_PORT_FILTER_LIMIT_STRING_LENGTH':
                                self.LIMIT_STRING_LENGTH = int(value.strip())

                            if k == 'CONTROL_PORT_FILTER_ALLOW_WILDCARDS':
                                self.ALLOW_WILDCARDS = value.strip() == 'true'

                            if k ==  'CONTROL_PORT_FILTER_LIMIT_GETINFO_NET_LISTENERS_SOCKS':
                                self.LIMIT_GETINFO_NET_LISTENERS_SOCKS = value.strip() == 'true'

                            if k == 'CONTROL_PORT_FILTER_WHITELIST':
                                # concatenate values from files, add a comma
                                RequestList = RequestList + value.strip() + ','

                            if k == 'CONTROL_PORT_FILTER_PORT':
                                self.PORT = int(value.strip())

                            if k == 'CONTROL_PORT_FILTER_IP':
                                self.IP = str(value.strip())

                            if k == 'CONTROL_PORT_SOCKET':
                                self.SOCKET = str(value.strip())

                            if k == 'CONTROL_PORT_AUTH_COOKIE':
                                self.AUTH_COOKIE = str(value.strip())

                            if k == 'CONTROL_PORT_FILTER_CONCURRENT_CONNECTIONS_LIMIT':
                                self.CONTROL_PORT_FILTER_CONCURRENT_CONNECTIONS_LIMIT = int(value.strip())

                            if k == 'ADD_ONION_INJECT_IP':
                                self.ADD_ONION_INJECT_IP = value.strip() == 'true'

                            if k == 'ONION_REJECT_OWN_IPS':
                                self.ONION_REJECT_OWN_IPS = value.strip() == 'true'

        # Disable limit.
        if self.LIMIT_STRING_LENGTH == -1:
            # "sock.recv()" requires an argument. 64 KB, arbitrary.
            self.LIMIT_STRING_LENGTH = 65536

        self.WHITELIST = RequestList.split(',')
        # Remove last element (comma)
        self.WHITELIST.pop()
        # Remove duplicates
        self.WHITELIST = list(set(self.WHITELIST))

        if not conf_found:
            return ('No valid configuration file found in configuration folder "/etc/cpfpy.d" ending with ".conf".'\
                    ' Running with default configuration.')


class TorConnectionHandler(asyncore.dispatcher):
    def __init__(self, client_socket):
        self.configuration = Configuration()
        self.configuration.read()

        self.to_send = ""
        self.client_socket = client_socket
        self.received_data = []
        self.chunk_size = self.configuration.LIMIT_STRING_LENGTH

        asyncore.dispatcher.__init__(self)

        # Connect to the real control port
        self.create_socket(socket.AF_UNIX, socket.SOCK_STREAM)
        self.connect(self.configuration.SOCKET)

        return

    def say(self, request):
        self.to_send = request + "\r\n"
        self.handle_write()

    def handle_connect(self):
        logger.info('TorConnectionHandler: Getting command on sock: %s'
                     % (self))

    def handle_close(self):
        logger.debug('TorConnectionHandler handle_close() begin')
        self.close()
        received_message = ''.join(self.received_data)
        ## Prevent extraneous new lines in logs.
        output_message = received_message.strip()
        logger.info('TorConnectionHandler handle_close(): answer by Tor: %s', output_message)
        logger.debug('TorConnectionHandler handle_close(): Closing connection. self.client_socket.close()')
        ## TODO: exception handling
        self.client_socket.close()
        logger.debug('TorConnectionHandler handle_close(): Closed connection on sock. self.client_socket: %s', self.client_socket)
        return

    def readable(self):
        #logger.debug('TorConnectionHandler readable() -> True')
        return True

    def writable(self):
        if self.to_send == "":
           #logger.debug('TorConnectionHandler writable empty: %s', self.to_send)
           return False
        else:
           #logger.debug('TorConnectionHandler writable non-empty: %s', self.to_send)
           return True

    def handle_write(self):
        #logger.debug('TorConnectionHandler handle_write begin')
        sent = self.send(self.to_send[:self.chunk_size])
        #logger.debug('TorConnectionHandler handle_write() -> (%d) "%s"', sent, self.to_send[:sent])
        self.to_send = self.to_send[sent:]
        #logger.debug('TorConnectionHandler handle_write end')

    def handle_read(self):
        data = self.recv(self.chunk_size)
        data_stripped = data.strip()
        logger.info('TorConnectionHandler handle_read(): answer by Tor: %s', (data_stripped))

        ## TODO: exception handling
        self.client_socket.send(data)

        self.received_data.append(data)

    def handle_error(self):
        t, v, tb = sys.exc_info()
        if t == socket.error:
            logger.error('TorConnectionHandler ERROR: %s' % (t))
            self.close()


class ControlPortFilterHandler(asyncore.dispatcher):
    def __init__(self, sock, client_ip, configuration):
        asyncore.dispatcher.__init__(self, sock=sock)

        self.client_ip = client_ip
        self.configuration = configuration
        self.request_buffer = ''
        try:
            self.tor_connection = TorConnectionHandler(self)
        except socket.error as e:
            logger.error(
                'client_handler: failed to connect to Tor: {!s}'.format(e))
            self.tor_connection = None
            self.close()

    def ip_list_own(self):
        ## http://stackoverflow.com/a/10377262/2605155

        ## A generator that returns stripped lines of output from "ip address show"
        iplines=(line.strip() for line in commands.getoutput("ip address show").split('\n'))

        ## Turn that into a list of IPv4 and IPv6 address/mask strings
        addresses1=reduce(lambda a,v:a+v,(re.findall(r"inet ([\d.]+/\d+)",line)+re.findall(r"inet6 ([\:\da-f]+/\d+)",line) for line in iplines))
        ## addresses1 now looks like ['127.0.0.1/8', '::1/128', '10.160.114.60/23', 'fe80::1031:3fff:fe00:6dce/64']

        ## Get a list of IPv4 addresses as (IPstring,subnetsize) tuples
        ipv4s=[(ip,int(subnet)) for ip,subnet in (addr.split('/') for addr in addresses1 if '.' in addr)]
        ## ipv4s now looks like [('127.0.0.1', 8), ('10.160.114.60', 23)]

        ## Get IPv6 addresses
        ipv6s=[(ip,int(subnet)) for ip,subnet in (addr.split('/') for addr in addresses1 if ':' in addr)]

        ip_list = []
        for ipv4_or_ipv6 in ipv4s, ipv6s:
          for own_ip_tulple in ipv4_or_ipv6:
              own_ip_address = own_ip_tulple[0]
              ip_list.append(own_ip_address)

        return ip_list

    def request_contains_wildcard(self, request):
        for item in self.configuration.WHITELIST:
            if '*' in item:
                item = item[:len(item)-2]
                if item in request:
                    return True
        return False

    def writable(self):
        # never wait for client socket being writable
        return False

    def handle_connect(self):
        logger.info('client_handler: Getting command on sock: %s'
                     % (self))

    def handle_read(self):
        logger.debug('client_handler: handle_read: IP: %s' % (self.client_ip))

        client_line = self.recv(self.configuration.LIMIT_STRING_LENGTH)
        if not client_line:
            logger.debug('client_handler: Client probably disconnected.')
            self.close()
            return
        else:
            self.request_buffer += client_line

            if self.request_buffer.__len__() > self.configuration.LIMIT_STRING_LENGTH:
                logger.error('client_handler: Excessive string length!')
                self.close()
                return

            if '\r\n' not in self.request_buffer:
                #logger.debug('client_handler: wait: wait more.')
                return
            #logger.debug('client_handler: wait: got enough.')
            request_end = self.request_buffer.find('\r\n')
            # Strip escaped chars and white spaces.
            # Convert to lowercase.
            request = self.request_buffer[:request_end].lower().strip()
            self.request_buffer = self.request_buffer[request_end + 2:]

        logger.info('client_handler: request: %s' % (request))
        request_startswith = request.split(' ', 1)[0]

        # TODO: If we were to add some bogus line here, we would get 100% cpu and no exception.
        #client_line = x

        # Don't check authentication, since only
        # safe requests are allowed
        if request_startswith == "authenticate":
            try:
                authentication_cookie_file_socket = open(self.configuration.AUTH_COOKIE, "rb")
                rawcookie = authentication_cookie_file_socket.read(32)
                authentication_cookie_file_socket.close()
                hexcookie = binascii.hexlify(rawcookie)
                request = "AUTHENTICATE " + hexcookie
                logger.debug('client_handler: request transformed to: %s' % (request))
                need_request = True
                do_break = False
            except:
                logger.error("client_handler: Authentication request message generation failed. Hopefully below this line is a better error message.")
                exception_msg = str(sys.exc_info()[0])
                logger.error(exception_msg)
                need_request = False
                do_break = True
                answer_faked = "515 Authentication failed: control-port-filter-python client_handler authentication message generation failed. exception_msg: " + exception_msg

        elif request_startswith == "authchallenge":
            need_request = False
            do_break = False
            answer_faked = "250 AUTHCHALLENGE SERVERHASH=D3A6FF5943582E95E3B8C5449AF30EC6A11BBB1513DE0ED9ED50AC6075046F48 SERVERNONCE45CBD16FCF5D9A529F0B3BF0F04E677609CDADA11E0"

        elif request_startswith == "quit":
            need_request = True
            do_break = True

        elif (request == 'getinfo net/listeners/socks' and self.configuration.LIMIT_GETINFO_NET_LISTENERS_SOCKS):
            need_request = False
            do_break = False
            answer_faked = '250-net/listeners/socks="127.0.0.1:9150"'

        elif (self.configuration.ALLOW_WILDCARDS and self.request_contains_wildcard(request)):
            need_request = True
            do_break = False

        elif request in self.configuration.WHITELIST:
            need_request = True
            do_break = False

        elif self.configuration.DISABLE_FILTERING:
            need_request = True
            do_break = False

        else:
            # Everything else we ignore/block
            need_request = False
            do_break = False
            answer_faked = "510 Request filtered"

        if request_startswith == "add_onion":
            if self.configuration.ADD_ONION_INJECT_IP == True:
                ## specific example:
                ## transform from: add_onion new:best port=80,17600
                ## transform to  : add_onion new:best port=80,10.137.6.41:17600
                ##
                ## generic example:
                ## transform from: add_onion new:best port=*,*
                ## transform to  : add_onion new:best port=80,ip:17600

                request_transformed = ""
                try:
                    if request_startswith == "add_onion":
                        for some_parameter in request.split():
                            if some_parameter.split("=")[0] == "port":
                                ports = some_parameter.split("=")[1]
                                ports_split = ports.split(",")
                                ports_parameter = "port=" + ports_split[0] + "," + self.client_ip + ":" + ports_split[1]
                                request_transformed = request_transformed + " " + ports_parameter
                            else:
                                request_transformed = request_transformed + " " + some_parameter

                    ## Removed leading space.
                    request_transformed = request_transformed.strip()
                    request = request_transformed
                    logger.debug('client_handler: request transformed to: %s' % (request))
                except:
                    need_request = False
                    answer_faked = "510 Request filtered: IP transformation failed"
                    exception_msg = str(sys.exc_info()[0])
                    logger.error("client_handler: Could not transform add_onion command. exception_msg: " + exception_msg)

            ## Test cases.
            #request = "add_onion new:best port=80,127.0.0.1:17600"

            if self.configuration.ONION_REJECT_OWN_IPS == True:
                try:
                    my_ips_list = self.ip_list_own()
                    for own_ip in my_ips_list:
                       logger.error('client_handler: own_ip: %s' % (own_ip))
                       if own_ip in request:
                           need_request = False
                           answer_faked = "510 Request filtered: matching add_onion for own IPs failed!"
                           logger.error('client_handler: own_ip in request, blocking! own_ip: %s' % (own_ip))
                           break
                except:
                    need_request = False
                    answer_faked = "510 Request filtered: matching add_onion for own IPs failed!"
                    exception_msg = str(sys.exc_info()[0])
                    logger.error("client_handler: matching add_onion for own IPs failed! exception_msg: " + exception_msg)

            if "nonanonymous" in request:
                need_request = False
                answer_faked = '510 Request filtered: add_onion contains "NonAnonymous"!'
                logger.error('510 Request filtered: add_onion contains "NonAnonymous"!')

        if need_request == True:
            self.tor_connection.say(request)
            if request_startswith == "quit":
                ## Give it half a second to catch Tor's answer before
                ## actually closing the client socket later.
                asyncore.loop(timeout=0.1, count=5)

        else:
            answer_faked = answer_faked + "\r\n"
            answer_faked_strip = answer_faked.strip()
            logger.info('client_handler: answer_faked by cpfpy: "%s"' % (answer_faked_strip))
            ## TODO: exception handling
            self.send(answer_faked)

        if do_break == True:
            logger.info('client_handler: Closing connection on '
                         'sock: %s' % (self))
            ## TODO: exception handling
            self.close()

    def handle_close(self):
        logger.info('client_handler: End of connection on sock: %s' %
                     (self))
        if self.tor_connection:
            self.tor_connection.close()

    def handle_error(self):
        t, v, tb = sys.exc_info()
        if t == socket.error:
            logger.error('client_handler ERROR: %s' % (t))
            self.close()

class ControlPortFilterServer(asyncore.dispatcher):
    def __init__(self):
        asyncore.dispatcher.__init__(self)
        self.connections = []

    def handle_accept(self):
        conn, addr = self.accept()
        client_ip = str(addr[0])
        self.connections.append(
            ControlPortFilterHandler(conn, client_ip, configuration=self.configuration))

    def handle_error(self):
        logger.error('ControlPortFilterServer: ERROR')
        t, v, tb = sys.exc_info()
        if t == socket.error:
            logger.error('ControlPortFilterServer: ERROR: %s' % (t))
            self.close()

    def run(self):
        self.configuration = Configuration()
        maybe_warning_message = self.configuration.read()
        if maybe_warning_message is not None:
            logger.warning(maybe_warning_message)

        # Catch server exceptions.
        try:
            logger.info("ControlPortFilterServer: Trying to start Tor control port filter on    IP %s port %s"
                        % (self.configuration.IP, self.configuration.PORT))
            # Accept concurrent connections.
            self.create_socket(socket.AF_INET, socket.SOCK_STREAM)

            ## TODO: May not be the cleanest solution. We should properly terminate sockets on shutdown.
            self.set_reuse_addr()

            self.bind((self.configuration.IP, self.configuration.PORT))
            # it isn't exactly connection limit - it a queue depth for
            # connections waiting to be handled
            self.listen(self.configuration.CONTROL_PORT_FILTER_CONCURRENT_CONNECTIONS_LIMIT)

            logger.info("ControlPortFilterServer: Tor control port filter started, listening on IP %s port %s"
                        % (self.configuration.IP, self.configuration.PORT))
        except IOError as e:
            logger.critical('ControlPortFilterServer: Server error %s' % (e))
            logger.critical('ControlPortFilterServer: Exiting.')
            sys.exit(1)

        try:
            asyncore.loop()
        except KeyboardInterrupt:
             logger.info('ControlPortFilterServer: KeyboardInterrupt.')
        except asyncore.ExitNow, e:
             logger.info('ControlPortFilterServer: asyncore.ExitNow e: %s' % (e))

        logger.info('ControlPortFilterServer: Shutting down...')
        asyncore.close_all()
        logger.info('ControlPortFilterServer: End.')

def sigterm_handler(_signo, _stack_frame):
    logger.info('Sigterm received.')
    asyncore.close_all()
    logger.info('End.')
    sys.exit(144)

def sigint_handler(_signo, _stack_frame):
    logger.info('Sigint received.')
    asyncore.close_all()
    logger.info('End.')
    sys.exit(144)

def handle_exception(exc_type, exc_value, exc_traceback):
    logger.error("Uncaught exception", exc_info=(exc_type, exc_value, exc_traceback))

if __name__ == "__main__":
    mypid = os.getpid()
    log_prefix = "CPFP " + str(mypid) + " log"
    logger = logging.getLogger(log_prefix)
    logger.setLevel(logging.DEBUG)

    formatter = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")
    handler = logging.StreamHandler(sys.stdout)
    handler.setFormatter(formatter)
    logger.addHandler(handler)

    cpfp = ControlPortFilterServer()

    signal.signal(signal.SIGTERM, sigterm_handler)
    signal.signal(signal.SIGINT, sigint_handler)
    sys.excepthook = handle_exception

    cpfp.run()
